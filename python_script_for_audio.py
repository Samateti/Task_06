# -*- coding: utf-8 -*-
"""python script for audio.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11J2LpCSCdrI63LMP0Lwo7H2-P8HHyjb3
"""

#@title üîä One-Cell MP3-Only Street Interview (Piper TTS)
import sys, subprocess, os, tarfile, urllib.request, time, shutil, stat, glob, re
from pathlib import Path

# ---------- helpers ----------
def sh(cmd, check=True):
    print("‚Üí", cmd)
    return subprocess.run(cmd, shell=True, check=check, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)

def download(urls, out_path, min_size=1024, retries=2):
    out = Path(out_path); out.parent.mkdir(parents=True, exist_ok=True)
    for u in urls:
        for i in range(retries):
            try:
                print(f"Downloading: {u}")
                urllib.request.urlretrieve(u, out.as_posix())
                if out.exists() and out.stat().st_size >= min_size:
                    return out
            except Exception as e:
                print("  failed:", e)
                time.sleep(1 + i)
    raise FileNotFoundError("Could not download from provided URLs.")

# ---------- deps ----------
sh("pip -q install pydub==0.25.1 soundfile==0.12.1")
sh("apt -q install -y ffmpeg")

# ---------- Piper binary ----------
PIPER_DIR = Path("/content/piper"); PIPER_DIR.mkdir(parents=True, exist_ok=True)
tgz = PIPER_DIR / "piper_linux_x86_64.tar.gz"
urls = [
    "https://github.com/rhasspy/piper/releases/download/2023.11.14-2/piper_linux_x86_64.tar.gz",
    "https://github.com/rhasspy/piper/releases/download/2023.11.14-2/piper_amd64.tar.gz",
]
need_bin = not (PIPER_DIR / "piper").exists()
if need_bin:
    download(urls, tgz)
    with tarfile.open(tgz, "r:gz") as tf:
        try:
            tf.extractall(PIPER_DIR, filter="data")  # safe extract on 3.12+
        except TypeError:
            tf.extractall(PIPER_DIR)

candidates = []
if (PIPER_DIR / "piper").is_file():
    candidates.append((PIPER_DIR / "piper").as_posix())
candidates += [p for p in glob.glob("/content/piper/**/piper", recursive=True) if os.path.isfile(p)]
if not candidates:
    raise FileNotFoundError("Piper binary not found after extraction.")
PIPER_BIN = candidates[0]
os.chmod(PIPER_BIN, os.stat(PIPER_BIN).st_mode | stat.S_IEXEC)
print("Using Piper binary:", PIPER_BIN)

# ---------- voices (HOST=Amy, GUEST=Ryan) ----------
voices = {
    "HOST": {
        "onnx": "https://huggingface.co/rhasspy/piper-voices/resolve/main/en/en_US/amy/low/en_US-amy-low.onnx",
        "json": "https://huggingface.co/rhasspy/piper-voices/resolve/main/en/en_US/amy/low/en_US-amy-low.onnx.json",
        "dir":  "/content/piper_models/en_US-amy-low"
    },
    "GUEST": {
        "onnx": "https://huggingface.co/rhasspy/piper-voices/resolve/main/en/en_US/ryan/low/en_US-ryan-low.onnx",
        "json": "https://huggingface.co/rhasspy/piper-voices/resolve/main/en/en_US/ryan/low/en_US-ryan-low.onnx.json",
        "dir":  "/content/piper_models/en_US-ryan-low"
    }
}
for role, v in voices.items():
    onnx = Path(v["dir"]) / Path(v["onnx"]).name
    jsn  = Path(v["dir"]) / Path(v["json"]).name
    if not onnx.exists(): download([v["onnx"]], onnx)
    if not jsn.exists():  download([v["json"]], jsn)

HOST_MODEL  = f'{voices["HOST"]["dir"]}/en_US-amy-low.onnx'
HOST_CFG    = f'{voices["HOST"]["dir"]}/en_US-amy-low.onnx.json'
GUEST_MODEL = f'{voices["GUEST"]["dir"]}/en_US-ryan-low.onnx'
GUEST_CFG   = f'{voices["GUEST"]["dir"]}/en_US-ryan-low.onnx.json'

# ---------- your street-style script (no variables) ----------
script_text = """
HOST: [street noise, sneakers on pavement] Yo‚Äîquick Orange check-in? Promise it‚Äôs a two-minute sidewalk chat.
GUEST: [laughs] Alright, hit me‚Äîmy rideshare‚Äôs almost here.
HOST: First gut check‚Äîseason felt pretty true to who the team is. Not broken, just a little wobble from luck here and there. Fair?
GUEST: Fair. The foundation‚Äôs solid. Clean up a few possessions and those coin-flip endings lean our way.
HOST: Real talk‚Äîdid defenses figure us out a bit?
GUEST: They keyed on the usual suspects. Our top options delivered, but the scoring clustered. Next step is spreading touches so the second wave can punch, too.
HOST: So, more paint on the palette‚Äîless ‚Äújust give it to the star and pray.‚Äù
GUEST: Exactly. Add weak-side actions, a couple counters off our favorite look, and suddenly the primary gets cleaner shots.
HOST: Those tight finishes‚Äîfelt like little things, not big problems.
GUEST: Totally. Line management, special-teams sequences, end-clock execution‚Äîtrainable margins. You flip a couple details and the final column looks different.
HOST: And when games went full track-meet?
GUEST: That‚Äôs where possession value spikes. We don‚Äôt need to win a sprint every night. Slow it just enough, choose better shots, protect the ball.
HOST: Give me the bus-stop plan in three beats.
GUEST: One‚Äîdiversify who initiates. Two‚Äîrehearse late-game packages until they‚Äôre automatic. Three‚Äîcontrol tempo when the pace gets silly. Same crew, smarter levers.
HOST: Love it. Shoutouts before you dip?
GUEST: Top line carried like pros; now it‚Äôs on the depth to raise the floor. When that happens, everybody‚Äôs life gets easier.
HOST: Say less. Appreciate the curbside download.
GUEST: Anytime‚Äîsee you on Marshall. [street noise fades]
HOST: Quick reminder‚Äîthis segment was AI-generated for academic research.
""".strip()

# ---------- parse lines ----------
def parse_lines(text: str):
    out = []
    for raw in text.splitlines():
        raw = raw.strip()
        if not raw or ":" not in raw:
            continue
        spk, spoken = raw.split(":", 1)
        spk = spk.strip().upper()
        spoken = re.sub(r"\[.*?\]", "", spoken).strip()
        if spoken:
            out.append((spk, spoken))
    return out

lines = parse_lines(script_text)
print(f"Parsed {len(lines)} lines.")

# ---------- synthesize ----------
OUT = Path("/content/interview_output"); LINES = OUT / "lines"
if LINES.exists(): shutil.rmtree(LINES)
LINES.mkdir(parents=True, exist_ok=True)

def piper_tts(text, model, config, out_wav, length_scale=1.0, noise_scale=0.667, sentence_silence=0.2):
    cmd = [
        PIPER_BIN, "--model", model, "--config", config,
        "--length_scale", str(length_scale), "--noise_scale", str(noise_scale),
        "--sentence_silence", str(sentence_silence), "--output_file", out_wav
    ]
    subprocess.run(cmd, input=text.encode("utf-8"), check=True)

fps = []
for i, (spk, txt) in enumerate(lines, 1):
    model, cfg = (HOST_MODEL, HOST_CFG) if spk == "HOST" else (GUEST_MODEL, GUEST_CFG)
    out_wav = (LINES / f"line_{i:03d}.wav").as_posix()
    piper_tts(txt, model, cfg, out_wav)
    fps.append(out_wav)
print(f"Synthesized {len(fps)} lines ‚Üí {LINES}")

# ---------- stitch & export MP3 only ----------
from pydub import AudioSegment
combined = None
for fp in fps:
    seg = AudioSegment.from_wav(fp).apply_gain(-1.5)  # small headroom
    combined = seg if combined is None else combined.append(seg, crossfade=35)

mp3_out = (OUT / "street_interview.mp3").as_posix()
combined.export(mp3_out, format="mp3", bitrate="192k")
print("Saved MP3:", mp3_out)

# Inline preview + auto-download
try:
    from IPython.display import Audio, display
    display(Audio(mp3_out))
except Exception as e:
    print("Inline preview unavailable:", e)

try:
    from google.colab import files
    files.download(mp3_out)
except Exception as e:
    print("Auto-download prompt not available:", e)